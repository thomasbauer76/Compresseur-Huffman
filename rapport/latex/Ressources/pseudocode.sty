%%
%% This is file `pseudocode.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% pseudocode.dtx  (with options: `package')
%% 
%% Copyright (C) 2023 by Anonymous
%% 
%% Package pseudocode.sty (version 3.0)
%% Envoyer toutes remarques a Nicolas.Delestre@insa-rouen.fr
%%
%%
%% Modifications depuis la version 2.7
%% * Suppression des commandes \typeProcedureAvecPreconditions, \typeFonctionAvecPreconditions
%%   \fonctionAvecPreconditions  \signatureFonctionAvecPreconditions, \procedureAvecPreconditions
%%   et \signatureProcedureAvecPreconditions
%% * Suppression des environnements algo et algoset
%% * Modification des commandes \typeProcedure, \typeFonction
%%   \fonction  \signatureFonction, \procedure et \signatureProcedure
%% * Ajout de la commande \tadParams qui généralise les autres commandes
%% (les paramètres sont séparés par des virgules)
%% * Généralisation de la commande \tableau (suppression de \tableauUneDimension \tableauDeuxDimensions)
%% * Généralisation de la commande \sialorssinon (suppression de \sialors)
%% * Ajout des commandes \typeEnumere \motclefReferencer et \adresse
%%
%%
%% Modifications de puis la version 2.6
%% * Amélioration de la notation des pointeurs
%%
%%
%% Modifications depuis la version 2.5
%% * Ajout des commandes \motclefPourChaque, \motclefPourChaqueDe et \pourChaque
%%
%%
%% Modifications depuis la version 2.4
%% * Ajout des commandes \typeProcedure, \typeFonction,
%% \typeProcedureAvecPreconditions, \typeFonctionAvecPreconditions
%%
%%
%% Modifications depuis la version 2.3.8
%% * Ajout de la commande \tadOperationAvecPreconditions
%% * Ajout des environnement tadPreconditions et des commandes
%%   \motclefTADPreconditions  et \tadPrecondition
%% * Ajout de la commande \champ
%% Modifications depuis la version 2.3.7
%% * Ajout des types de base naturelNonNul, reelPositif, reelPositifNonNul (resp Negatif)
%% * Elimination d'accents dans les mots cles lies à l'algorithmique
%% * ajout de la commande \commentaire
%% Modification depuis la version 2.3.6
%%   * Ajout des commandes \fonctionAvecPreconditions
%%   \signatureFonctionAvecPreconditions, \procedureAvecPreconditions
%%   et \signatureProcedureAvecPreconditions
%%   * remplacement de structure et champStructure par enregistrement et champEnregistrement
%%
%%
%% Modification depuis la version 2.3.5
%%   * Suppression de la commande \programme
%%
%%
%% Modification depuis la version 2.3.4
%%   * Dans les commandes fonction et procedure, modification du test pour savoir si les variables locales sont presentes ou pas.
%%   * Suppresion de l'erreur de compilation du a la redefinition de l'environnement structure
%%
%%
%% Modification depuis la version 2.3.2
%%   * structure est maintenant un environnement qui s'integre dans l'environnement algorithme
%%   * \champStructure a pris une majuscule
%%   * Apparition de \tadSemantiquesAxiomatiques
%%   * Apparition de l'environnement \tadAxiomes et et commande \tadAxiome
%%   * Apparition de \typePointeur, \pointeur, \pointeurNULL, \champPointee, \allouer, \desallouer
%%   * Elimination de l'erreur de compilation lie a la defintion de la commande \structure
%%
\NeedsTeXFormat{LaTeX2e}[2005/12/01]
\ProvidesPackage{pseudocode}
 [2002/12/22 v2.7 package pseudocode]
 \RequirePackage{calc}
 \RequirePackage[utf8]{inputenc}
 \RequirePackage{amssymb}
 \RequirePackage{pgffor}
%% Definition des mots clefs \\
%% peuvent être redéfinis à l'aide de la commande \renewcommand
%%
\newcommand{\motclefAffectation}[0]{$\leftarrow$}
\newcommand{\motclefAlgoDebut}[0]{debut}
\newcommand{\motclefAlgoFin}[0]{fin}
\newcommand{\motclefEntier}[0]{Entier}
\newcommand{\motclefNaturel}[0]{Naturel}
\newcommand{\motclefNaturelNonNul}[0]{NaturelNonNul}
\newcommand{\motclefReel}[0]{Reel}
\newcommand{\motclefReelPositif}[0]{ReelPositif}
\newcommand{\motclefReelPositifNonNul}[0]{ReelPositifNonNul}
\newcommand{\motclefReelNegatif}[0]{ReelNegatif}
\newcommand{\motclefReelNegatifNonNul}[0]{ReelNegatifNonNul}
\newcommand{\motclefBooleen}[0]{Booleen}
\newcommand{\motclefCaractere}[0]{Caractere}
\newcommand{\motclefChaine}[0]{Chaine de caracteres}
\newcommand{\motclefRemarque}[0]{Remarque}
\newcommand{\motclefCommentaire}[0]{// }
\newcommand{\motclefType}[0]{Type}
\newcommand{\motclefDeclaration}[0]{Déclaration}
\newcommand{\motclefConstante}[0]{Constante}
\newcommand{\motclefTableau}[0]{Tableau}
\newcommand{\motclefStructure}[0]{Structure}
\newcommand{\motclefFinstructure}[0]{finstructure}
\newcommand{\motclefSi}[0]{si}
\newcommand{\motclefAlors}[0]{alors}
\newcommand{\motclefSinon}[0]{sinon}
\newcommand{\motclefFinsi}[0]{finsi}
\newcommand{\motclefCasou}[0]{cas où}
\newcommand{\motclefCasouVaut}[0]{vaut}
\newcommand{\motclefFincas}[0]{fincas}
\newcommand{\motclefTantque}[0]{tant que}
\newcommand{\motclefTantqueFaire}[0]{faire}
\newcommand{\motclefFintantque}[0]{fintantque}
\newcommand{\motclefRepeter}[0]{repeter}
\newcommand{\motclefJusquaceque}[0]{jusqu'a ce que}
\newcommand{\motclefPour}[0]{pour}
\newcommand{\motclefPourA}[0]{à}
\newcommand{\motclefPourPas}[0]{pas de}
\newcommand{\motclefPourFaire}[0]{faire}
\newcommand{\motclefFinPour}[0]{finpour}
\newcommand{\motclefPourChaque}[0]{pour chaque}
\newcommand{\motclefPourChaqueDe}[0]{de}
\newcommand{\motclefEcrire}[0]{ecrire}
\newcommand{\motclefLire}[0]{lire}
\newcommand{\motclefPreconditions}[0]{précondition(s)}
\newcommand{\motclefFonction}[0]{fonction}
\newcommand{\motclefRetourner}[0]{retourner}
\newcommand{\motclefProcedure}[0]{procédure}
\newcommand{\motclefParamEntree}[0]{E}
\newcommand{\motclefParamSortie}[0]{S}
\newcommand{\motclefParamEntreeSortie}[0]{E/S}
\newcommand{\motclefTADNom}[0]{Nom}
\newcommand{\motclefTADParametre}[0]{Paramètre}
\newcommand{\motclefTADUtilise}[0]{Utilise}
\newcommand{\motclefTADOperations}[0]{Opérations}
\newcommand{\motclefTADSemantiques}[0]{Sémantiques}
\newcommand{\motclefTADAxiomes}[0]{Axiomes}
\newcommand{\motclefTADPreconditions}[0]{Préconditions}
\newcommand{\motclefPointeurNULL}[0]{null}
\newcommand{\motclefAllouer}[0]{allouer}
\newcommand{\motclefDesallouer}[0]{desallouer}
\newcommand{\motclefDereferencer}[0]{\textasciicircum{}}
\newcommand{\motclefReferencer}[0]{@}

%% ------------------------------------------------------------
%% Définitions privées

%% Permet d'étendre le nombre de niveau maximale pour l'environnment list
\csname @listdepth\endcsname=-10

%% L'environnement \algolist
\newenvironment{algolist}[1]
{\begin{list}
    {}
    {\setlength{\parsep}{0cm}
      \setlength{\leftmargin}{#1}
      \setlength{\itemsep}{0cm}
      \setlength{\topsep}{0cm}
    }
}
{\end{list}}

%% Commande \preconditions
%% #1 : les préconditions séparées par //
\newcommand{\preconditions}[1]{
  \ifx\empty#1\empty
  \else
  \begin{listeAligneeSanssf}{$\lfloor$\textbf{\motclefPreconditions \ }}{0.5cm}{}
    \item[$\lfloor$\textbf{\motclefPreconditions \ }] #1
  \end{listeAligneeSanssf}
  \fi
}

%% Commande \variables
%% #1 : Variable(s) a declarée(s)
\newcommand{\variables}[1]{
  \begin{listeAligneeSanssf}{\textbf{\motclefDeclaration \ }}{0.5cm}{}
    \item[\textbf{\motclefDeclaration \ }] #1
  \end{listeAligneeSanssf}
}

%% Définition d'un bloc d'instructions
\newcommand{\unbloc}[1]{
  \begin{algolist}{0,5cm}
     #1
  \end{algolist}
}

\newcommand{\entetealgo}[6]{
  \instruction{\textbf{\motclefAlgoNom : }#1}
  \instruction{\textbf{\motclefAlgoRole : }#2}
  \instruction{\textbf{\motclefAlgoEntree : }#3}
  \instruction{\textbf{\motclefAlgoSortie : }#4}
  \instruction{\textbf{\motclefAlgoEntreeSortie : }#5}
  \instruction{\textbf{\motclefAlgoDeclaration : }#6}
}

\newcommand{\debutfin}[1]{
  \instruction{\textbf{\motclefAlgoDebut}}
  \unbloc{#1}
  \instruction{\textbf{\motclefAlgoFin}}
}

%% Des listes alignees
%% #1 : le mot de reference
%% #2 : l'espace depuis le cote gauche
%% #3 : le separateur
\newenvironment{listeAlignee}[3]%
{\begin{list}{}
    {\renewcommand{\makelabel}[1]{\textsf{##1#3}\hfil}
      \settowidth{\labelwidth}{\textsf{#1#3}}%
      \setlength{\leftmargin}{\labelwidth+\labelsep+#2}
      \setlength{\itemsep}{0cm}
    }
  }%
{\end{list}}

\newenvironment{listeAligneeSanssf}[3]%
{\begin{list}{}
    {\renewcommand{\makelabel}[1]{##1#3\hfil}
      \settowidth{\labelwidth}{#1#3}%
      \setlength{\leftmargin}{\labelwidth+\labelsep+#2}
      \setlength{\itemsep}{0cm}
    }
  }%
{\end{list}}

%% ------------------------------------------------------------
%% DEPRECATED
\newcommand{\tableauUneDimension}[3]{\textbf{\motclefTableau[}#1\textbf{] #2}#3}
\newcommand{\tableauDeuxDimensions}[4]{\textbf{\motclefTableau[}#1\textbf{]}\textbf{[}#2\textbf{] #3} #4}

%% Commandes \tadXXParams
%% Produit cartesien des types des parametres
%% Plusieurs commande car pour l'instant impossible de créer une commande avec nombre d'arguement variable
\newcommand{\tadUnParam}[1]{#1}
\newcommand{\tadDeuxParams}[2]{#1 $\times$ #2}
\newcommand{\tadTroisParams}[3]{#1 $\times$ #2 $\times$ #3}
\newcommand{\tadQuatreParams}[4]{#1 $\times$ #2 $\times$ #3 $\times$ #4}
\newcommand{\tadCinqParams}[5]{#1 $\times$ #2 $\times$ #3 $\times$ #4 $\times$ #5}
\newcommand{\tadSixParams}[6]{#1 $\times$ #2 $\times$ #3 $\times$ #4 $\times$ #5  $\times$ #6}
\newcommand{\tadSeptParams}[7]{#1 $\times$ #2 $\times$ #3 $\times$ #4 $\times$ #5  $\times$ #6  $\times$ #7}
\newcommand{\tadHuitParams}[8]{#1 $\times$ #2 $\times$ #3 $\times$ #4 $\times$ #5  $\times$ #6  $\times$ #7  $\times$ #8}
\newcommand{\tadNeufParams}[9]{#1 $\times$ #2 $\times$ #3 $\times$ #4 $\times$ #5  $\times$ #6  $\times$ #7  $\times$ #8 $\times$ #9}

\newenvironment{axiomelist}[1]
{\begin{list}
    {-}
    {\setlength{\parsep}{0cm}
      \setlength{\leftmargin}{#1}
      \setlength{\itemsep}{0cm}
      \setlength{\topsep}{0cm}
    }
}
{\end{list}}

%% toutes les semantiques d'operations (\tadSemantiquesAxiomatiques) doivent etre definies dans un environnement tadSemantiquesAxiomatiques
\newenvironment{tadSemantiquesAxiomatiques}[1]
{\item[\textbf{\motclefTADSemantiques}]
  \begin{listeAlignee}{#1}{0cm}{ =}
}
{\end{listeAlignee}}

\newcommand{\sialors}[2]{
  \instruction{\textbf{\motclefSi} #1 \textbf{\motclefAlors}}
    \unbloc{#2}
  \instruction{\textbf{\motclefFinsi}}
}
%% ------------------------------------------------------------
%% Toutes les commandes de ce package, à l'exception des TAD, doivent être utilisées au sein de l'environnement algorithme,
%% donc entre les commandes |\begin{algorithme}| et |\end{alorithme}|
%% Noter qu'un algorithme peut contenir plusieurs fonction(s) et procédure(s).
\newenvironment{algorithme}{\begin{algolist}{0cm}}{\end{algolist}}
%% Les commandes |\nomDuType| servent à utiliser les différents types existants. Voici les types disponibles : \\
%% Les types de bases
\newcommand{\entier}{\textbf{\motclefEntier}}
\newcommand{\naturel}{\textbf{\motclefNaturel}}
\newcommand{\naturelNonNul}{\textbf{\motclefNaturelNonNul}}
\newcommand{\reel}{\textbf{\motclefReel}}
\newcommand{\reelPositif}{\textbf{\motclefReelPositif}}
\newcommand{\reelPositifNonNul}{\textbf{\motclefReelPositifNonNul}}
\newcommand{\reelNegatif}{\textbf{\motclefReelNegatif}}
\newcommand{\reelNegatifNonNul}{\textbf{\motclefReelNegatifNonNul}}
\newcommand{\booleen}{\textbf{\motclefBooleen}}
\newcommand{\caractere}{\textbf{\motclefCaractere}}
\newcommand{\chaine}{\textbf{\motclefChaine}}
%% La commande |\tableau| sert à déclarer un type tableau à n dimensions \\
%% \#1 : Intervalles des dimensions (indices du tableau), séparés par une virgule \\
%% \#2 : {de} ou {d'} \\
%% \#3 : Type des éléments du tableau \\
\newcommand{\tableau}[3]{%
\textbf{\motclefTableau[}%
  \gdef\firstelement{1}%
  \foreach \arg in {#1}{%
    \ifnum\firstelement=0\textbf{][}\fi\arg%
    \gdef\firstelement{0}%
  }%
  \textbf{] #2} #3
}
%% La commande |\constante| sert à déclarer une constante \\
%% \#1 : Nom de la constante \\
%% \#2 : Valeur de la constante \\
\newcommand{\constante}[2]{
  \textbf{\motclefConstante \ }#1\textbf{ = }#2
}
%% La commande |\typeEnumere| sert à déclarer un type énuméré \\
%% \#1 : Nom de l'énuméré \\
%% \#2 : Enumération des valeurs possibles \\
\newcommand{\typeEnumere}[2]{%
\type{#1}{ \{#2\} }
}
%% La commande |\typePointeur| sert à déclarer un pointeur \\
%% \#1 : Type sur lequel le pointeur pointe \\
\newcommand{\typePointeur}[1]{\motclefDereferencer #1}
%% L'environnement \verb|enregistrement| à utiliser entre |\begin{enregistrement}| et |\end{enregistrement}| sert à déclarer un type particulier : les structures. \\
%% \#1 : nom de la structure \\
%% Pour pouvoir l'alimenter, c'est-à-dire lui attribuer des champs, il faut utiliser la commande |\champEnregistrement|.\\
%% \#1 : nom du champ \\
%% \#2 : type du champ \\
%% Pour accéder au champ d'une structure, on utilise la commande \verb|\champ|.\\
%% \#1 : nom de la variable du type structure \\
%% \#2 : nom du champ à accéder \\
\newenvironment{enregistrement}[1]
{\type{#1}{\textbf{\motclefStructure}}\begin{algolist}{0.5cm}}
{\end{algolist}\instruction{\textbf{\motclefFinstructure}}}

\newcommand{\champEnregistrement}[2]{
\instruction{#1 : #2}
}

\newcommand{\champ}[2]{%
#1.#2%
}
%% La commande |\type| permet de définir un nouveau type. \\
%% \#1 : Nom du nouveau type \\
%% \#2 : Définition du type \\
\newcommand{\type}[2]{
  \instruction{\textbf{\motclefType \ }#1\textbf{ = }#2}
}
%% La définition d'un tad se fait dans un environnement tad, entre |\begin{tad}|
%% et |\end{tad}|. \\[0.3cm]
%%
%% |\tadNom| prend en paramètre le \textbf{nom} du TAD \\[0.1cm]
%% |\tadParametres| prend en paramètre les différents \textbf{paramètres} du TAD \\[0.1cm]
%% |\tadDependances| prend en paramètre les \textbf{dépendances} du TAD vis à vis d'autre types \\[0.3cm]
%%
%% Les définitions d'\textbf{opérations} doivent se situer dans l'environnement tadOperations,
%% entre |\begin{tadOperations}{nomLePlusLong}| et |\end{tadOperations}|. Le nom le plus long parmi les opérations doit être mis en paramètre. \\
%% Les commandes |\tadOperation| et |\tadOperationAvecPrecondition| servent à définir
%% les différentes opérations du TAD \\
%% \textbf{Paramètres :} \\
%% \#1 : Nom de l'operation \\
%% \#2 : Paramètres en entrée de l'opération (utiliser |\tadParams|) \\
%% \#3 : Paramètres en sortie de l'opération(utiliser |\tadParams|) \\[0.3cm]
%%
%% Toutes les \textbf{semantiques}, définies grâce à la commande |\tadSemantique|, doivent être définies dans l'environnement tadSemantiques,
%% entre |\begin{tadSemantiques}{nomLePlusLong}| et |\end{tadSemantiques}|. Le nom le plus long parmi les sémantiques doit être mis en paramètre. \\[0.3cm]
%%
%% Tous les \textbf{axiomes}, définis grâce à la commande |\tadAxiome|, doivent être utilisés dans l'environnement
%% tadAxiomes, entre |\begin{tadAxiomes}| et |\end{tadAxiomes}|. \\[0.3cm]
%%
%% Toutes les \textbf{préconditions} d'operations doivent être definies dans un environnement tadPreconditions, entre
%% |\begin{tadPreconditions}{nomLePlusLong}| et |\end{tadPreconditions}|. Le nom le plus long parmi les préconditions doit être mis en paramètre. \\
%% La commande |\tadPrecondition| sert à définir une précondition \\
%% \textbf{Paramètres :} \\
%% \#1 : Nom de l'operation \\
%% \#2 : la précondition \\
%% La définition d'un tad ce fait dans un environnement tad
\newenvironment{tad}{\begin{listeAlignee}{\textbf{\motclefTADPreconditions}}{0cm}{:}}{\end{listeAlignee}}

\newcommand{\tadNom}[1]{\item[\textbf{\motclefTADNom}] #1}

\newcommand{\tadParametres}[1]{\item[\textbf{\motclefTADParametre}] #1}

\newcommand{\tadDependances}[1]{\item[\textbf{\motclefTADUtilise}] #1}

%% toutes les operations (tadOperation) doivent etre definies dans un environnement tadOperations
\newenvironment{tadOperations}[1]
{\item[\textbf{\motclefTADOperations}]
  \begin{listeAlignee}{#1}{0cm}{:}
}
{\end{listeAlignee}}

\newcommand{\tadParams}[1]{%
  \gdef\firstelement{1}
  \foreach \arg in {#1}{%
    \ifnum\firstelement=0\ $\times$ \fi \arg%
    \gdef\firstelement{0}%
  }
}

\newcommand{\tadOperation}[3]{\item[#1] #2 $\rightarrow$ #3}

\newcommand{\tadOperationAvecPreconditions}[3]{\item[#1] #2 $\nrightarrow$ #3}

%% toutes les semantiques d'operations (\tadSemantique) doivent etre definies dans un environnement tadSemantiques
\newenvironment{tadSemantiques}[1]
{\item[\textbf{\motclefTADSemantiques}]
  \begin{listeAlignee}{#1}{0cm}{:}
}
{\end{listeAlignee}}

\newcommand{\tadSemantique}[2]{\item[#1] #2}

%% les axiomes doivent être définis dans l'environnement tadAxiomes
\newenvironment{tadAxiomes}[0]
{\item[\textbf{\motclefTADAxiomes}]
  \begin{axiomelist}{0cm}
}
{\end{axiomelist}}

\newcommand{\tadAxiome}[1]{\item $#1$}

%% toutes les préconditions d'operations (\tadPrecondition) doivent etre definies dans un environnement tadPreconditions
\newenvironment{tadPreconditions}[1]
{\item[\textbf{\motclefTADPreconditions}]
  \begin{listeAlignee}{#1}{0cm}{:}
}
{\end{listeAlignee}}

\newcommand{\tadPrecondition}[2]{\item[#1] #2}
%% La commande |\typeFonction| est à utiliser comme deuxième paramètre de la
%% commande |\type| \\
%% \#1 : les paramètres \\
%% \#2 : le type de retour \\
%% \#3 : les préconditions (peut être vide) \\
\newcommand{\typeFonction}[3] {
  \instruction{\textbf{\motclefFonction}(#1) : #2
  \ifx\empty#3\empty
  \else \\$\lfloor$\textbf{\motclefPreconditions \ } #3}
  \fi
}
%% La commande |\signatureFonction| est utilisée pour définir la signature
%% d'une fonction \\
%% \#1 : Nom de la fonction \\
%% \#2 : Paramètres formels \\
%% \#3 : Type de retour \\
%% \#4 : Préconditions (peut être vide) \\
\newcommand{\signatureFonction}[4]{
  \instruction{\textbf{\motclefFonction} #1 \textbf{(}#2\textbf{)} \textbf{:} #3}
  \preconditions{#4}
}
%% La commande |\fonction| sert à définir une fonction \\
%% \#1 : Nom de la fonction \\
%% \#2 : Paramètres formels \\
%% \#3 : Type de retour \\
%% \#4 : Préconditions (peut être vide) \\
%% \#5 : Déclaration des variables locales (peut être vide) \\
%% \#6 : Instructions
\newcommand{\fonction}[6]{
  \instruction{\textbf{\motclefFonction} #1 \textbf{(}#2\textbf{)} \textbf{:} #3}
  \preconditions{#4}
  \ifx\empty#5\empty
  \else
  \variables{#5}
  \fi
  \debutfin{#6}
}
%% Les commandes |\paramEntree|, |\paramSortie|, et |\paramEntreeSortie| permettent
%% de définir le type de passage de paramètre des paramètres formels d'une procédure. \\ \textit{(Les deux backslash} |\\| \textit{permettent
%% juste de sauter une ligne pour des raisons esthétiques mais ils ne sont pas utiles)}
\newcommand{\paramEntree}[1]{\textbf{\motclefParamEntree} #1}
\newcommand{\paramSortie}[1]{\textbf{\motclefParamSortie} #1}
\newcommand{\paramEntreeSortie}[1]{\textbf{\motclefParamEntreeSortie} #1}
%% La commande |\typeProcedure| est utilisée comme deuxième paramètre de la
%% commande |\type| \\
%% \#1 : les paramètres formels \\
%% \#2 : les préconditions (peut être vide) \\
\newcommand{\typeProcedure}[2] {
  \instruction{\textbf{\motclefProcedure}(#1)
  \ifx\empty#2\empty
  \else \\$\lfloor$\textbf{\motclefPreconditions \ } #2}
  \fi
}
%% La commande |\signatureProcedure| est utilisée pour définir la signature d'une
%% procédure \\
%% \#1 : Nom de la procedure \\
%% \#2 : Paramètres formels \\
%% \#3 : Préconditions (peut être vide) \\
\newcommand{\signatureProcedure}[3]{
  \instruction{\textbf{\motclefProcedure} #1 \textbf{(}#2\textbf{)}}
  \preconditions{#3}
}
%% La commande |\procedure| sert à écrire une procédure en pseudocode. \\
%% \#1 : Nom de la procedure \\
%% \#2 : Paramètres formels \\
%% \#3 : Préconditions (peut être vide) \\
%% \#4 : Déclaration des variables locales (peut être vide) \\
%% \#5 : Corps de la procédure \\
\newcommand{\procedure}[5]{
  \instruction{\textbf{\motclefProcedure} #1 \textbf{(}#2\textbf{)}}
  \preconditions{#3}
  \ifx\empty#4\empty
  \else
  \variables{#4}
  \fi
  \debutfin{#5}
}
%% La commande |\affecter| sert à donner une valeur à une variable.\\
%% \#1 : la variable \\
%% \#2 : la valeur qu'on veut lui donner \\
\newcommand{\affecter}[2]{
\instruction{#1 \textbf{\motclefAffectation} #2}
}
%% La commande |\retourner| sert à définir ce qu'une fonction va renvoyer.\\
%% \#1 : ce qu'on veut renvoyer \\
\newcommand{\retourner}[1]{
\instruction{\textbf{\motclefRetourner} #1}
}
%% La commande |\lire| sert à lire ce que l'utilisateur rentre par l'entrée standard (au clavier).\\
%% \#1 : la variable à laquelle on veut affecter une valeur \\
\newcommand{\lire}[1]{
\instruction{\textbf{\motclefLire}(#1)}
}
%% La commande |\ecrire| sert à afficher du contenu dans le périphérique de sortie standard (l'écran la plupart du temps).\\
%% \#1 : ce qu'on veut afficher : soit directement une chaîne de caractères, soit une variable et dans ce cas son contenu s'affichera \\
\newcommand{\ecrire}[1]{
\instruction{\textbf{\motclefEcrire}(#1)}
}
%% La commande |\instruction| est à utiliser pour toute autre instruction non présente parmi celles présentées ci-dessus.\\
%% \#1 : nom de l'instruction \\
\newcommand{\instruction}[1]{
  \item #1
}
%% La commande |\sialorssinon| sert à réaliser une boucle conditionnelle si sinon, c'est à dire réaliser une instruction si la condition est vérifiée et une autre sinon \\
%% \#1 : Condition \\
%% \#2 : Instruction à réaliser si la condition est vraie \\
%% \#3 : Instruction à réaliser si la condition est fausse (peut être vide) \\
\newcommand{\sialorssinon}[3]{
  \instruction{\textbf{\motclefSi} #1 \textbf{\motclefAlors}}
    \unbloc{#2}
  \ifx\empty#3\empty
  \else
  \instruction{\textbf{\motclefSinon}}
    \unbloc{#3}
  \fi
  \instruction{\textbf{\motclefFinsi}}
}
%% La commande |\cas| sert à réaliser un switch case. \\
%% \#1 : La variable pour laquelle on fait le switch case \\
%% \#2 : Les différents cas (|\casclausegenerale| ou |\casclauseautre|) \\
%% La commande |\casclausegenerale| sert à définir une clause générale dans un switch case. \\
%% \#1 : La valeur de la variable \\
%% \#2 : L'instruction à effectuer si la variable vaut cette valeur \\
%% La commande |\casclauseautre| sert à définir la clause par défaut dans un switch case. \\
%% \#1 : L'instruction par défaut à effectuer si toutes les autres clauses sont fausses \\
\newcommand{\cas}[2]{
  \instruction{\textbf{\motclefCasou} #1 \textbf{\motclefCasouVaut}}
  \unbloc{#2}
  \instruction{\textbf{\motclefFincas}}
  }

  \newcommand{\casclausegenerale}[2]{
  \instruction{\textit{#1}: }
  \unbloc{#2}
  }

  \newcommand{\casclauseautre}[1]{
  \instruction{\textit{autre} : }
  \unbloc{#1}
  }
%% La commande |\pour| sert à réaliser une itération déterministe \verb|pour| \\
%% \#1 : Variable \\
%% \#2 : Borne inférieure \\
%% \#3 : Borne supérieure \\
%% \#4 : Le pas (peut être vide et dans ce cas pas=1) \\
%% \#5 : Instruction(s) \\
\newcommand{\pour}[5]{
\instruction{\textbf{\motclefPour} #1 \motclefAffectation  #2 \textbf{\motclefPourA} #3 \ifx#4\ \else \textbf{\motclefPourPas} #4 \fi\textbf{\motclefPourFaire}}
\unbloc{#5}
\instruction{\textbf{\motclefFinPour}}
}
%% La commande |\pourChaque| sert à réaliser une itération déterministe \verb|pour chaque| \\
%% \#1 : Variable \\
%% \#2 : Liste \\
%% \#3 : Instruction(s) \\
\newcommand{\pourChaque}[3]{
  \instruction{\textbf{\motclefPourChaque} #1 \textbf{\motclefPourChaqueDe} #2}
  \unbloc{#3}
  \instruction{\textbf{\motclefFinPour}}
}
%% La commande |\tantque| sert à réaliser une boucle indéterministe \verb|tant que|. \\
%% \#1 : Condition \\
%% \#2 : Instruction(s) à réaliser tant que la condition est vraie \\

\newcommand{\tantque}[2]{
  \instruction{\textbf{\motclefTantque} #1 \textbf{\motclefTantqueFaire}}
  \unbloc{#2}
  \instruction{\textbf{\motclefFintantque}}
}
%% La commande |\repeter| sert à réaliser une boucle indéterministe \verb|répéter...jusqu'à ce que|. \\
%% \#1 : Condition \\
%% \#2 : Instruction(s) à réaliser jusqu'à ce que la condition soit fausse \\

\newcommand{\repeter}[2]{
  \instruction{\textbf{\motclefRepeter}}
    \unbloc{#1}
  \instruction{\textbf{\motclefJusquaceque} #2}
}
%% Les commandes, |\pointeur|, |\pointeurNULL|, |\allouer|,
%% |\desallouer|, |\adresse| servent à utiliser les pointeurs dans un algorithme. \\
\newcommand{\pointeur}[1]{#1\motclefDereferencer}
\newcommand{\pointeurNULL}[0]{\textbf{\motclefPointeurNULL}}
\newcommand{\allouer}[1]{\textbf{\motclefAllouer}(#1)}
\newcommand{\desallouer}[1]{\textbf{\motclefDesallouer}(#1)}
\newcommand{\adresse}[1]{\motclefReferencer #1}
%% La commande |\champPointeur| sert à accéder au champ d'un pointeur sur une structure. \\
\newcommand{\champPointeur}[2]{#1$\rightarrow$#2}
%% Il est important de rappeler que pour la maintenabilité d'un code, ainsi que sa lisibilité, il faut le documenter. C'est pour cela qu'il existe ces deux commandes.
\newcommand{\remarque}[1]{
\instruction{\textit{\textbf{Remarque : }#1}}
}
\newcommand{\commentaire}[1]{
\textit{// #1}
}

\endinput
%%
%% End of file `pseudocode.sty'.
